<!--
  ~ Copyright 2024 Robert A. James
  ~
  ~ Licensed under the Apache License, Version 2.0 (the "License");
  ~ you may not use this file except in compliance with the License.
  ~ You may obtain a copy of the License at
  ~
  ~   http://www.apache.org/licenses/LICENSE-2.0
  ~
  ~ Unless required by applicable law or agreed to in writing, software
  ~ distributed under the License is distributed on an "AS IS" BASIS,
  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  ~ See the License for the specific language governing permissions and
  ~ limitations under the License.
  -->

<!DOCTYPE>
<!-- saved from url=(0060)https://users.ece.cmu.edu/~koopman/stack_computers/appb.html -->
<html lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <title>Stack Computers: Appendix B -- A Glossary of Forth Primitives

    </title>

    <link href="mailto:koopman@cmu.edu">
</head>

<body>

<p><a href="https://users.ece.cmu.edu/~koopman/stack_computers/index.html"><b>Stack Computers</b></a>: the new wave

    <img src="./Stack Computers_ Appendix B -- A Glossary of Forth Primitives_files/horiz_sp.gif" alt=""> Â© Copyright 1989,

    <i><a href="https://www.cs.cmu.edu/~koopman/index.html">Philip Koopman,</a></i>

    <a href="https://users.ece.cmu.edu/~koopman/stack_computers/copyrght.html">All Rights Reserved.</a>

</p>

<p></p>

<hr>

<p>

</p>

<h1>Appendix B<br> A Glossary of Forth Primitives

</h1>

<p>The Forth language is based on an extensible, interactive compiler that

    creates code for a virtual stack machine. The virtual machine has two stacks.

    The Data Stack is used for expression evaluation and subroutine parameter

    passing. The Return Stack is used for subroutine return address saving and for

    loop control variable storage. The source code for Forth directly reflects the

    underlying stack machine, and so uses Reverse Polish Notation (RPN) to perform

    all operations using.

</p>

<p>Forth programs are built as a hierarchy of subroutines. Each subroutine is

    called a "word" in Forth terminology. A program consists of a single

    Forth word which calls several other Forth words, and so on, forming a

    tree-structured program. At the lowest level, the leaves of the tree are

    invocations of Forth primitive words that manipulate the stacks and perform

    arithmetic.

</p>

<p>Below is a glossary of the Forth primitive words found on stack machines

    discussed in this book. Most of these primitives are actually applicable to

    any program written in any language on a stack machine (for example, addition

    of the top two stack elements or swapping the order of the top two stack

    elements). Forth nomenclature is used in discussions to maintain consistency

    with an existing standard vocabulary for stack machine operation.

</p>

<p>Each Forth word is followed by a "stack picture" on the same

    line. This stack picture shows the input parameters and output parameters on

    the Forth Data Stack for the word being described. The values on the left of

    the "_" indicate the input parameters while those to the right of the

    "_" indicate output parameters. Each parameter list is ordered with

    the topmost stack element to the right. Notation in the stack lists is as

    follows: N1, N2, N3, etc. indicate single-precision integers. D1, D2, etc.

    indicate double-precision integers, which take up two elements on the data

    stack. ADDR indicates an address, which may be thought of as a pointer value.

    FLAG is an integer which is false if zero, true if non-zero. A more detailed

    glossary of Forth is Haydon's All About Forth (1983).

</p>

<p></p>

<pre>0             - 0

Push the integer 0 onto the stack.



0&lt;         N1 - FLAG

Return a true FLAG if N1 is negative.



0=         N1 - FLAG

Return a true FLAG if N1 is zero.



0          N1 - FLAG

Return a true FLAG if N1 is greater than zero.



0BRANCH    N1 - 

If N1 is false (value is 0) perform a branch to the

address in the next program cell, otherwise continue.



1+         N1 - N2

Add one to N1, returning N2.



1-         N1 - N2

Subtract one from N1, returning N2.



2+         N1 - N2

Add two to N1, returning N2.



2*         N1 - N2

Multiply N1 by two, returning N2.



2/         N1 - N2

Divide N1 by two, returning N2.



4+         N1 - N2

Add four to N1, returning N2.



&lt;       N1 N2 - FLAG

Return a true FLAG if N1 is less than N2.



&lt;&gt;      N1 N2 - FLAG

Return a true FLAG if N1 is not equal to N2.



=       N1 N2 - FLAG

Return a true FLAG if N1 equals N2.



R          N1 - 

Push N1 onto the return stack.



&gt;       N1 N2 - FLAG

Return a true FLAG if N1 is greater than N2.



!     N1 ADDR -

Store N1 at location ADDR in program memory.



+       N1 N2 - N3

Add N1 and N2, giving sum N3.



+!    N1 ADDR -

Add N1 to the value pointed to by ADDR.



-       N1 N2 - N3

Subtract N2 from N1, giving difference N3.



:             -

Define the start of a subroutine.  The primitive

[CALL] is compiled every time this subroutine is

reference by other definitions.



;             -

Perform a subroutine return and end the definition

of a subroutine.  The primitive [EXIT] is compiled.



?DUP       N1 - N1 N1   ( if N1 non-zero )

           N1 - N1      ( if N1 is zero  )

Conditionally duplicate the input N1 if it is

non-zero.



@       ADDR  - N1&lt;

Fetch the value at location ADDR in program memory,

returning N1.



ABS        N1 - N2

Take the absolute value of N1 and return the result N2.



AND     N1 N2 - N3

Perform a bitwise AND on N1 and N2, giving result N3.



BRANCH        -

Perform an unconditional branch to the compiled in-line

address.



D!    D1 ADDR -

Store the double-precision value D1 at the two memory

words starting at ADDR.



D+      D1 D2 - D3

Return the double precision sum of D1 and D2 as D3.



D@       ADDR - D1

Fetch the double precision value D1 from memory starting

at address ADDR.



DDROP      D1 -

Drop the double-precision integer D1.



DDUP       D1 - D1 D1

Duplicate D1 on the stack.



DNEGATE    D1 - D2

Return D2, which is the two's complement of D1.



DROP       N1 - 

Drop N1 from the stack.



DSWAP   D1 D2 - D2 D1

Swap the top two double-precision numbers on the stack.



DUP        N1 - N1 N1

Duplicate N1, returning a second copy of it on the stack.



I             - N1

Return the index of the currently active loop.



I'            - N1

Return the limit of the currently active loop.



J             - N1

Return the index of the outer loop in a nested loop structure.



LEAVE         -

Set the loop counter on the return stack equal to the

loop limit to force an exit from the loop.



LIT           - N1

Treat the compiled in-line value as an integer constant,

and push it onto the stack as N1.



NEGATE     N1 - N2

Return N2, which is the two's complement of N1

NOP           -

Do nothing.



NOT     FLAG1 - FLAG2

Synonym for 0=.  Takes the inverse of a flag value.



OR      N1 N2 - N3

Perform a bitwise OR on N1 and N2, giving result N3.



OVER    N1 N2 - N1 N2 N1

Push a copy of the second element on the stack, N1, onto

the top of the stack.



PICK   ... N1 - ... N2

Copy the N1'th element deep in the data stack to the top.

In Forth-83, 0 PICK is equivalent to DUP , and 1 PICK 

is equivalent to OVER .



R&gt;           - N1

Pop the top element of the return stack, and push it onto

the data stack as N1.



R@            - N1

Copy the top Return Stack word N1 onto the Data Stack.



ROLL   ... N1 - ... N2

Pull the N1'th element deep in the data stack to the top,

closing the hole left in the stack.  In Forth-83, 1 ROLL

is equivalent to SWAP , and 2 ROLL is equivalent to ROT.



ROT  N1 N2 N3 - N2 N3 N1

Pull the third element down in the stack onto the top of

the stack.



S-D        N1 - D2

Sign extend N1 to occupy two words, making it a double

precision integer D2.



SWAP    N1 N2 - N2 N1

Swap the order of the top two stack elements.



U&lt;      U1 U2 - FLAG

Return a true FLAG if U1 is less than U2 when compared

as unsigned integers.



U       U1 U2 - FLAG

Return a true FLAG if U1 is greater than U2 when compared

as unsigned integers.



U*      N1 N2 - D3

Perform unsigned integer multiplication on N1 and N2,

yielding the unsigned double precision result D3.



U/MOD   D1 N2 - N3 N4

Perform unsigned integer division on D1 and N2, yielding

the quotient N4 and the remainder N3.



XOR     N1 N2 - N3

Perform a bitwise exclusive OR on N1 and N2, giving result N3.



</pre>

<p></p>

<hr>

<p><!-- standard trailer --><a href="https://users.ece.cmu.edu/~koopman/stack_computers/contents.html"><img src="./Stack Computers_ Appendix B -- A Glossary of Forth Primitives_files/contents.gif" alt="CONTENTS"></a>

    <a href="https://users.ece.cmu.edu/~koopman/stack_computers/index.html"><img src="./Stack Computers_ Appendix B -- A Glossary of Forth Primitives_files/top.gif" alt="TOP"></a>

    <img src="./Stack Computers_ Appendix B -- A Glossary of Forth Primitives_files/horiz_sp.gif" alt="">

    <a href="https://users.ece.cmu.edu/~koopman/stack_computers/appa.html"><img src="./Stack Computers_ Appendix B -- A Glossary of Forth Primitives_files/prev.gif" alt="PREV CHAP"></a>

    <img src="./Stack Computers_ Appendix B -- A Glossary of Forth Primitives_files/horiz_sp.gif" alt="">

    <a href="https://users.ece.cmu.edu/~koopman/stack_computers/appc.html"><img src="./Stack Computers_ Appendix B -- A Glossary of Forth Primitives_files/next.gif" alt="NEXT APP"></a> NEXT APPENDIX

</p>

<p><a href="https://www.cs.cmu.edu/~koopman/index.html"><img src="./Stack Computers_ Appendix B -- A Glossary of Forth Primitives_files/home.gif" alt="HOME"></a> Phil Koopman --

    <a href="mailto:koopman@cmu.edu">koopman@cmu.edu</a>

</p>

</body>
</html>